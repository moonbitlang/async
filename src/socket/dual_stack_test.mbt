// Copyright 2025 International Digital Economy Academy
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///|
let all_protocol_preferences : FixedArray[@socket.IpProtocolPreference] = [
  @socket.FavorV4,
  @socket.OnlyV4,
  @socket.FavorV6,
  @socket.OnlyV6,
]

///|
async test "Only_V4 server" {
  let log = StringBuilder::new()
  let port = 4209
  @async.with_task_group(fn(root) {
    root.spawn_bg(no_wait=true, fn() {
      let server = @socket.TcpServer::new(
        @socket.Addr::parse("0.0.0.0:\{port}"),
      )
      defer server.close()
      for {
        let (conn, addr) = server.accept()
        defer conn.close()
        let addr_str = addr.to_string()
        guard addr_str.rev_find(":") is Some(ip_end)
        let ip = addr_str[:ip_end]
        let msg = conn.read_all().text()
        log.write_string("server received \{repr(msg)} from \{ip}\n")
      }
    })
    async fn client(protocol) {
      let conn = @socket.Tcp::connect_to_host("localhost", port~, protocol~)
      defer conn.close()
      conn.write("message")
    }

    for protocol in all_protocol_preferences {
      let result = try? client(protocol)
      @async.sleep(100)
      log.write_string("client(\{protocol}): \{result}\n")
    }
    // give some time for the server to process the last connection
    @async.sleep(300)
  })
  inspect(
    log.to_string(),
    content=(
      #|server received "message" from 127.0.0.1
      #|client(FavorV4): Ok(())
      #|server received "message" from 127.0.0.1
      #|client(OnlyV4): Ok(())
      #|server received "message" from 127.0.0.1
      #|client(FavorV6): Ok(())
      #|client(OnlyV6): Err(OSError("@socket.Tcp::connect(): Connection refused"))
      #|
    ),
  )
}

///|
async test "Only_V6 server" {
  let log = StringBuilder::new()
  let port = 4210
  @async.with_task_group(fn(root) {
    root.spawn_bg(no_wait=true, fn() {
      let server = @socket.TcpServer::new(
        @socket.Addr::parse("[::]:\{port}"),
        dual_stack=false,
      )
      for {
        let (conn, addr) = server.accept()
        defer conn.close()
        let addr_str = addr.to_string()
        guard addr_str.rev_find(":") is Some(ip_end)
        let ip = addr_str[:ip_end]
        let msg = conn.read_all().text()
        log.write_string("server received \{repr(msg)} from \{ip}\n")
      }
    })
    async fn client(protocol) {
      let conn = @socket.Tcp::connect_to_host("localhost", port~, protocol~)
      defer conn.close()
      conn.write("message")
    }

    for protocol in all_protocol_preferences {
      let result = try? client(protocol)
      @async.sleep(100)
      log.write_string("client(\{protocol}): \{result}\n")
    }
    // give some time for the server to process the last connection
    @async.sleep(300)
  })
  inspect(
    log.to_string(),
    content=(
      #|server received "message" from [::1]
      #|client(FavorV4): Ok(())
      #|client(OnlyV4): Err(OSError("@socket.Tcp::connect(): Connection refused"))
      #|server received "message" from [::1]
      #|client(FavorV6): Ok(())
      #|server received "message" from [::1]
      #|client(OnlyV6): Ok(())
      #|
    ),
  )
}

///|
async test "dual stack server" {
  let log = StringBuilder::new()
  let port = 4211
  @async.with_task_group(fn(root) {
    root.spawn_bg(no_wait=true, fn() {
      let server = @socket.TcpServer::new(@socket.Addr::parse("[::]:\{port}"))
      for {
        let (conn, addr) = server.accept()
        defer conn.close()
        let addr_str = addr.to_string()
        guard addr_str.rev_find(":") is Some(ip_end)
        let ip = addr_str[:ip_end]
        let msg = conn.read_all().text()
        log.write_string("server received \{repr(msg)} from \{ip}\n")
      }
    })
    async fn client(protocol) {
      let conn = @socket.Tcp::connect_to_host("localhost", port~, protocol~)
      defer conn.close()
      conn.write("message")
    }

    for protocol in all_protocol_preferences {
      let result = try? client(protocol)
      @async.sleep(100)
      log.write_string("client(\{protocol}): \{result}\n")
    }
    // give some time for the server to process the last connection
    @async.sleep(300)
  })
  inspect(
    log.to_string(),
    content=(
      #|server received "message" from [::ffff:127.0.0.1]
      #|client(FavorV4): Ok(())
      #|server received "message" from [::ffff:127.0.0.1]
      #|client(OnlyV4): Ok(())
      #|server received "message" from [::1]
      #|client(FavorV6): Ok(())
      #|server received "message" from [::1]
      #|client(OnlyV6): Ok(())
      #|
    ),
  )
}

///|
async test "Only_V4 UDP server" {
  let log = StringBuilder::new()
  let port = 4209
  @async.with_task_group(fn(root) {
    root.spawn_bg(no_wait=true, fn() {
      let server = @socket.UdpServer::new(
        @socket.Addr::parse("0.0.0.0:\{port}"),
      )
      defer server.close()
      let buf = FixedArray::make(1024, b'\x00')
      for {
        let (len, addr) = server.recvfrom(buf)
        let msg = @encoding/utf8.decode(buf.unsafe_reinterpret_as_bytes()[:len])
        let addr_str = addr.to_string()
        guard addr_str.rev_find(":") is Some(ip_end)
        let ip = addr_str[:ip_end]
        log.write_string("server received \{repr(msg)} from \{ip}\n")
      }
    })
    async fn client(protocol) {
      let addr = @socket.Addr::resolve("localhost", port~, protocol~)
      let client = @socket.UdpClient::new(addr)
      defer client.close()
      client.send("message")
    }

    for protocol in all_protocol_preferences {
      let result = try? client(protocol)
      @async.sleep(100)
      log.write_string("client(\{protocol}): \{result}\n")
    }
    // give some time for the server to process the last connection
    @async.sleep(300)
  })
  inspect(
    log.to_string(),
    content=(
      #|server received "message" from 127.0.0.1
      #|client(FavorV4): Ok(())
      #|server received "message" from 127.0.0.1
      #|client(OnlyV4): Ok(())
      #|client(FavorV6): Ok(())
      #|client(OnlyV6): Ok(())
      #|
    ),
  )
}

///|
async test "Only_V6 UDP server" {
  let log = StringBuilder::new()
  let port = 4210
  @async.with_task_group(fn(root) {
    root.spawn_bg(no_wait=true, fn() {
      let server = @socket.UdpServer::new(
        @socket.Addr::parse("[::]:\{port}"),
        dual_stack=false,
      )
      defer server.close()
      let buf = FixedArray::make(1024, b'\x00')
      for {
        let (len, addr) = server.recvfrom(buf)
        let msg = @encoding/utf8.decode(buf.unsafe_reinterpret_as_bytes()[:len])
        let addr_str = addr.to_string()
        guard addr_str.rev_find(":") is Some(ip_end)
        let ip = addr_str[:ip_end]
        log.write_string("server received \{repr(msg)} from \{ip}\n")
      }
    })
    async fn client(protocol) {
      let addr = @socket.Addr::resolve("localhost", port~, protocol~)
      let client = @socket.UdpClient::new(addr)
      defer client.close()
      client.send("message")
    }

    for protocol in all_protocol_preferences {
      let result = try? client(protocol)
      @async.sleep(100)
      log.write_string("client(\{protocol}): \{result}\n")
    }
    // give some time for the server to process the last connection
    @async.sleep(300)
  })
  inspect(
    log.to_string(),
    content=(
      #|client(FavorV4): Ok(())
      #|client(OnlyV4): Ok(())
      #|server received "message" from [::1]
      #|client(FavorV6): Ok(())
      #|server received "message" from [::1]
      #|client(OnlyV6): Ok(())
      #|
    ),
  )
}

///|
async test "dual stack UDP server" {
  let log = StringBuilder::new()
  let port = 4211
  @async.with_task_group(fn(root) {
    root.spawn_bg(no_wait=true, fn() {
      let server = @socket.UdpServer::new(@socket.Addr::parse("[::]:\{port}"))
      defer server.close()
      let buf = FixedArray::make(1024, b'\x00')
      for {
        let (len, addr) = server.recvfrom(buf)
        let msg = @encoding/utf8.decode(buf.unsafe_reinterpret_as_bytes()[:len])
        let addr_str = addr.to_string()
        guard addr_str.rev_find(":") is Some(ip_end)
        let ip = addr_str[:ip_end]
        log.write_string("server received \{repr(msg)} from \{ip}\n")
      }
    })
    async fn client(protocol) {
      let addr = @socket.Addr::resolve("localhost", port~, protocol~)
      let client = @socket.UdpClient::new(addr)
      defer client.close()
      client.send("message")
    }

    for protocol in all_protocol_preferences {
      let result = try? client(protocol)
      @async.sleep(100)
      log.write_string("client(\{protocol}): \{result}\n")
    }
    // give some time for the server to process the last connection
    @async.sleep(300)
  })
  inspect(
    log.to_string(),
    content=(
      #|server received "message" from [::ffff:127.0.0.1]
      #|client(FavorV4): Ok(())
      #|server received "message" from [::ffff:127.0.0.1]
      #|client(OnlyV4): Ok(())
      #|server received "message" from [::1]
      #|client(FavorV6): Ok(())
      #|server received "message" from [::1]
      #|client(OnlyV6): Ok(())
      #|
    ),
  )
}
