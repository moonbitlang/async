// Copyright 2025 International Digital Economy Academy
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// A network address containing an IP address and port number.
/// Supports both IPv4 and IPv6 addresses.
///
/// IPv4 addresses are stored as 32-bit integers, while IPv6 addresses
/// are stored as 16-byte arrays. The address type is automatically
/// detected and handled transparently.
struct Addr(Bytes) derive(Eq, Compare, Hash)

/// Create a new IPv4 address from an IP address and port number.
///
/// # Parameters
/// - `ip`: The IPv4 address as a 32-bit unsigned integer in network byte order
/// - `port`: The port number (0-65535)
///
/// # Example
/// ```
/// let addr = Addr::new(0x7F000001U, 8080) // 127.0.0.1:8080
/// ```
pub extern "C" fn Addr::new(ip : UInt, port : Int) -> Addr = "moonbitlang_async_make_ip_addr"

///|
extern "C" fn Addr::empty() -> Addr = "moonbitlang_async_make_empty_addr"

///|
#borrow(ip)
extern "C" fn Addr::new_ipv6(ip : FixedArray[Byte], port : Int) -> Addr = "moonbitlang_async_make_ipv6_addr"

///|
#borrow(addr)
pub extern "C" fn Addr::ip(addr : Addr) -> UInt = "moonbitlang_async_ip_addr_get_ip"

/// Get the port number from an address.
///
/// # Returns
/// The port number as an integer (0-65535)
///
/// # Example
/// ```
/// let addr = Addr::parse("127.0.0.1:8080")!
/// println(addr.port()) // 8080
/// ```
#borrow(addr)
pub extern "C" fn Addr::port(addr : Addr) -> Int = "moonbitlang_async_ip_addr_get_port"

/// Check if this address is an IPv6 address.
///
/// # Returns
/// `true` if this is an IPv6 address, `false` if it's an IPv4 address.
///
/// # Example
/// ```
/// let ipv4 = Addr::parse("127.0.0.1:8080")!
/// let ipv6 = Addr::parse("[::1]:8080")!
/// println(ipv4.is_ipv6()) // false
/// println(ipv6.is_ipv6()) // true
/// ```
#borrow(addr)
pub extern "C" fn Addr::is_ipv6(addr : Addr) -> Bool = "moonbitlang_async_addr_is_ipv6"

///|
#borrow(addr)
extern "C" fn Addr::get_ipv6_byte(addr : Addr, index : Int) -> Int = "moonbitlang_async_addr_get_ipv6_byte"

///|
fn Addr::is_ipv6_wildcard(addr : Addr) -> Bool {
  for i in 0..<16 {
    if addr.get_ipv6_byte(i) != 0 {
      break false
    }
  } else {
    true
  }
}

///|
pub impl Show for Addr with output(self, logger) {
  if self.is_ipv6() {
    // IPv6 address format
    logger.write_char('[')
    self.write_ipv6(logger)
    logger..write_char(']')..write_char(':')..write_object(self.port())
  } else {
    // IPv4 address format
    let ip = self.ip()
    let port = self.port()
    logger
    ..write_object(ip >> 24)
    ..write_char('.')
    ..write_object((ip >> 16) & 255)
    ..write_char('.')
    ..write_object((ip >> 8) & 255)
    ..write_char('.')
    ..write_object(ip & 255)
    ..write_char(':')
    ..write_object(port)
  }
}

/// Error raised when an address string cannot be parsed.
///
/// This error is raised when:
/// - The IP address format is invalid
/// - The port number is out of range (not 0-65535)
/// - The address string format is malformed
pub suberror InvalidAddr derive(Show)

/// Parse a string into an IPv4 or IPv6 address.
///
/// # Format
/// - IPv4: `"192.168.1.1:8080"`
/// - IPv6: `"[::1]:8080"` or `"[2001:db8::1]:80"`
///
/// # Parameters
/// - `src`: The address string to parse
///
/// # Returns
/// The parsed `Addr` object
///
/// # Raises
/// `InvalidAddr` if the string format is invalid
///
/// # Example
/// ```
/// let ipv4 = Addr::parse("127.0.0.1:8080")!
/// let ipv6 = Addr::parse("[::1]:8080")!
/// ```
// TODO: faster implementation
pub fn Addr::parse(src : String) -> Addr raise InvalidAddr {
  if src.has_prefix("[") {
    let (ip_bytes, port, _, _) = try_parse_ipv6(src)
    let ip_bytes = ip_bytes.map(x => x.to_byte())
    Addr::new_ipv6(ip_bytes, port)
  } else {
    // IPv4 format: ip:port
    let (ip, port) = try_parse_ipv4(src) catch { _ => raise InvalidAddr }
    guard 0 <= port && port < 65536 else { raise InvalidAddr }
    Addr::new(ip, port)
  }
}

///|
typealias @event_loop.AddrInfo

///|
extern "C" fn AddrInfo::is_null(self : AddrInfo) -> Bool = "moonbitlang_async_addrinfo_is_null"

///|
/// Convert AddrInfo to Addr(support both IPv4 and IPv6)
extern "C" fn AddrInfo::to_addr(self : AddrInfo, port : Int) -> Addr = "moonbitlang_async_addrinfo_to_addr"

///|
extern "C" fn AddrInfo::next(self : AddrInfo) -> AddrInfo = "moonbitlang_async_addrinfo_get_next"

///|
extern "C" fn AddrInfo::free(self : AddrInfo) = "freeaddrinfo"

///|
/// Error message from failure in resolving a network hostname.
/// The content of the error message is platfrom-dependent,
/// so users should never depend on it.
pub suberror ResolveHostnameError String derive(Show)

/// IP protocol preference for address resolution and connection establishment.
///
/// Controls whether to prefer IPv4 or IPv6 when both are available:
/// - `OnlyV4`: Only use IPv4 addresses
/// - `OnlyV6`: Only use IPv6 addresses  
/// - `FavorV4`: Prefer IPv4, fallback to IPv6 if IPv4 unavailable
/// - `FavorV6`: Prefer IPv6, fallback to IPv4 if IPv6 unavailable
/// - `NoPreference`: Use the first available address (default)
pub(all) enum IpProtocolPreference {
  OnlyV4
  OnlyV6
  FavorV4
  FavorV6
  NoPreference
} derive(Show)

///|
/// Resolve a IPv4 or IPv6 address by hostname.
///
By default, `Addr::resolve` returns the first available address.
/// Preference on IPv4 v.s. IPv6 can be configured via `protocol`.
/// See `IpProtocolPreference` for available options.
///
/// # Parameters
/// - `host`: The hostname to resolve (e.g., "example.com")
/// - `port`: The port number to use
/// - `protocol`: IP protocol preference (default: `NoPreference`)
///
/// # Returns
/// The resolved `Addr` object
///
/// # Raises
/// `ResolveHostnameError` if hostname resolution fails or no address of the preferred type is found.
///
/// # Example
/// ```
/// let addr = Addr::resolve("example.com", port=80)!
/// let ipv4_addr = Addr::resolve("example.com", port=80, protocol=OnlyV4)!
/// ```
pub async fn Addr::resolve(
  host : String,
  port~ : Int,
  protocol? : IpProtocolPreference = NoPreference,
) -> Addr {
  // TODO: Add option to prefer ipv6 or ipv4
  let context = "@socket.Addr::resolve()"
  let ai_root = match @event_loop.getaddrinfo(host, context~) {
    Ok(ai_root) => ai_root
    Err(msg) => raise ResolveHostnameError(msg)
  }
  defer ai_root.free()
  let first_addr = ai_root.to_addr(port)

  // search for address with preferred protocol
  match protocol {
    FavorV4 | OnlyV4 => {
      if not(first_addr.is_ipv6()) {
        return first_addr
      }
      for ai = ai_root.next(); not(ai.is_null()); ai = ai.next() {
        let addr = ai.to_addr(port)
        if not(addr.is_ipv6()) {
          return addr
        }
      }
      if protocol is OnlyV4 {
        raise ResolveHostnameError("No available IPv4 address")
      } else {
        first_addr
      }
    }
    FavorV6 | OnlyV6 => {
      if first_addr.is_ipv6() {
        return first_addr
      }
      for ai = ai_root.next(); not(ai.is_null()); ai = ai.next() {
        let addr = ai.to_addr(port)
        if addr.is_ipv6() {
          return addr
        }
      }
      if protocol is OnlyV6 {
        raise ResolveHostnameError("No available IPv6 address")
      } else {
        first_addr
      }
    }
    NoPreference => first_addr
  }
}
